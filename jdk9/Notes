Using AOSDBOptCompile and not compiling methods which have been compiled as OSR atleast once in vanilla HotSpot:

(i)./java -XX:FreqInlineSize=0 -XX:-TimeOSRCompilationInAOSDB -XX:-CompileOSRAtLevelInAOSDB -XX:+NotCompileOSRMethodsInAOSDB -XX:+NotCompileInPolicy -XX:-ProfileInterpreter -XX:-BackgroundCompilation -XX:+UseAOSDBOptCompile -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintInlining -jar dacapo.jar avrora

(ii)./java -XX:-ProfileInterpreter -XX:FreqInlineSize=0 -XX:+NoOSRForFindLoop -XX:-OnlyMakeOSRForMethodsInAOSDB -XX:-CompileOSRAtLevelInAOSDB -XX:+NotCompileOSRMethodsInAOSDB -XX:+UseAOSDBRead -XX:+RangeCheckElimination -XX:-BackgroundCompilation -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintInlining -jar dacapo.jar avrora

(i) performs 1.1x better than (ii). The condition "not compiling methods which have been compiled as OSR atleast once in vanilla HotSpot" is added because method "fastLoop" is first compiled as OSR at level 3 and then as normal method at level 4. If the condition is just not to compile an OSR method, then "fastLoop" gets compiled at level 4 directly by (i) but (ii) goes through OSR at 3 and then at 4, which is unfair to be honest. Moreover, it is also made sure that none of the methods which are not listed in AOSDB are not compiled in both (i) and (ii).

In the above case we do not set -XX:MaxInlineSize=0. Setting this option in both cases decreases speedup to 1.04x. However, in "fastLoop", inling of two functions happens in (ii) which has to be stopped.

Hence, we need to develop technique so that if a method is compiled as OSR atleast once then (i) this OSR method is first compiled at level 3, which takes less time than 4 and the OSR would happen at the loop's backward edge, and (ii) the method at level 3 will be eventually replaced by method at level 4.


Using AOSDBOptCompile with OSR:

Original Args:
(i) ./java -XX:-UseAOSDBVerbose -XX:-PrintInLoopEvent -XX:-FastLoopMaxInlineSize0 -XX:-NormalCompilationForFastLoopInPolicy -XX:-CompileFastLoopAtOSRNextLevel -XX:+NormalCompilationForFindLoop -XX:+OSRCompileInLoopEvent -XX:-UseAOSDBVerboseOSR -XX:+OSRInLoopEvent -XX:FreqInlineSize=0 -XX:-TimeOSRCompilationInAOSDB -XX:-CompileFastLoopAtOSR4 -XX:-CompileFastLoopAtOSR3 -XX:-CompileOSRAtLevelInAOSDB -XX:+NotCompileOSRMethodsInAOSDB -XX:+NotCompileInPolicy -XX:-ProfileInterpreter -XX:-BackgroundCompilation -XX:+UseAOSDBOptCompile -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -jar dacapo.jar avrora > out1.txt

(ii) ./java -XX:-FastLoopMaxInlineSize0 -XX:-BlockLayoutByFrequency -XX:+CompileFastLoopAtOSRNextLevel -XX:+NormalCompilationForFastLoopInPolicy -XX:-ProfileInterpreter -XX:FreqInlineSize=0 -XX:-NoOSRForFindLoop -XX:-OnlyMakeOSRForMethodsInAOSDB -XX:+CompileOSRAtLevelInAOSDB -XX:-NotCompileOSRMethodsInAOSDB -XX:+UseAOSDBRead -XX:+RangeCheckElimination -XX:-BackgroundCompilation -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -XX:-LogCompilation -jar dacapo.jar avrora > printcompilation1.txt

Cleaned Up Command Line Args:
(i) ./java -XX:+OSRInLoopEvent -XX:FreqInlineSize=0 -XX:+NotCompileOSRMethodsInAOSDB -XX:+NotCompileInPolicy -XX:-ProfileInterpreter -XX:-BackgroundCompilation -XX:+UseAOSDBOptCompile -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -jar dacapo.jar avrora > out1.txt

(ii) ./java -XX:-ProfileInterpreter -XX:FreqInlineSize=0 -XX:-NotCompileOSRMethodsInAOSDB -XX:+UseAOSDBRead -XX:-BackgroundCompilation -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -XX:-LogCompilation -jar dacapo.jar avrora > printcompilation1.txt

With this OSR compilation has been implemented too, and (i) performs with a speedup of 1.15x than (ii).

Inlining:

To record data use:
./java -XX:-C1ProfileInlinedCalls -XX:+UseAOSDBRecordHotData -XX:+UseAOSDBRecordCallProfile -XX:+UseAOSDBRecord -jar dacapo.jar avrora

Command Line Args:
(iii) ./java -XX:-UseAOSDBPrintInline -XX:+InlineOnlyIfInlinedInDB -XX:-UseAOSDBStatistics -XX:-TurnOffInlining -XX:+UseAOSDBHotData -XX:+UseAOSDBCallProfile -XX:+OSRInLoopEvent -XX:+NotCompileOSRMethodsInAOSDB -XX:-NotCompileInPolicy -XX:-ProfileInterpreter -XX:-BackgroundCompilation -XX:+UseAOSDBOptCompile -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -jar dacapo.jar avrora

(iv) ./java -XX:-UseAOSDBPrintInline -XX:-InlineOnlyIfInlinedInDB -XX:-UseAOSDBStatistics -XX:-TurnOffInlining -XX:+UseAOSDBHotData -XX:+UseAOSDBCallProfile -XX:+OSRInLoopEvent -XX:+NotCompileOSRMethodsInAOSDB -XX:-NotCompileInPolicy -XX:-ProfileInterpreter -XX:-BackgroundCompilation -XX:+UseAOSDBOptCompile -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:-C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:-C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -jar dacapo.jar avrora

(v) ./java -XX:-UseAOSDBPrintInline -XX:-TurnOffInlining -XX:+ProfileInterpreter -XX:-NotCompileOSRMethodsInAOSDB -XX:+UseAOSDBRead -XX:-BackgroundCompilation -XX:-UseOnlyInlinedBimorphic -XX:-TimeLinearScan -XX:-UseTypeProfile -XX:-C1ProfileVirtualCalls -XX:-UseInlineCaches -XX:+C1ProfileInlinedCalls -XX:-UseTypeSpeculation -XX:-C1ProfileBranches -XX:-C1ProfileCalls -XX:-C1ProfileCheckcasts -XX:-C1OptimizeVirtualCallProfiling -XX:+C1UpdateMethodData -XX:-PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:-PrintNMethods -XX:-PrintInlining -XX:-LogCompilation -jar dacapo.jar avrora

UseAOSDBHotData and UseAOSDBCallProfile enables the use of Inlining in C2 compiler. InlineOnlyIfInlinedInDB inlines only if the callee has been inlined in the caller in DB, i.e., in the DB training run. The baseline here is (iii). -XX:+ProfileInterpreter is required for inlining in (v) but is not needed in others. 
While recording data it is required to have -XX:-C1ProfileInlinedCalls because otherwise the number of inlinings recorded will be too many and both (iii) and (iv) will show some overhead over (i). On the other hand, InlineOnlyIfInlinedInDB should be enabled to make sure that number of inlinings are not too many, hence, the overhead is not so much. In (v) all options through which inlining profile data can be collected are enabled. 
Finally (iii) perform at a speedup of 1.08x over (v). and (iii) shows a little bit of overhead over (i). 
InlineOnlyIfInlinedInDB can also be used to search through a file containing callees inlined into callers. This file can be obtained by dumping all data using -XX:+UseAOSDBPrintInlining. Performance is almost same as (iii).

To Do:
Immediate Next Step is to add inlining in C1 compiler.
(i) Collect more data for Inlining, Branch Prediction and all other optimizations.
(ii) In case we have enough profile data for a method, and it has been compiled 
  at level 3, then compile it at level 4 or 2 or 1, depending on whether the 
  data is correct for this program instance also i.e. are the program inputs same.
  Since, level 3 runs 30% slower than level 2 and also level 4.
(iii) Also, think about the load on Level 3 and 4 compilers. Since, most of the methods 
  are compiled at these levels, this load should be distributed to level 2 by
  compiling the method at level 2 and wait for level 3 to compile it.

