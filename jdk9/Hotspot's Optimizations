The Server VM contains an advanced adaptive compiler that supports many of the same types of optimizations performed by optimizing C++ compilers, as well as some optimizations that cannot be done by traditional compilers, such as aggressive inlining across virtual method invocations. This is a competitive and performance advantage over static compilers. Adaptive optimization technology is very flexible in its approach, and typically outperforms even advanced static analysis and compilation techniques.


    Deep inlining and inlining of potentially virtual calls: as described above, method inlining combined with global analysis and dynamic deoptimization are used by both the client and server compilers to enable deep inlining and therefore elimination of a substantial amount of method call overhead.
    Fast instanceof/checkcast: the Java HotSpot VM and compilers support a novel technique for accelerating the dynamic type tests frequently required by the Java programming language for type safety. This further decreases the run-time cost of programming in object-oriented style.
    Range check elimination: The Java programming language specification requires array bounds checking to be performed with each array access. An index bounds check can be eliminated when the compiler can prove that an index used for an array access is within bounds.
    Loop unrolling: the Server VM features loop unrolling, a standard compiler optimization that enables faster loop execution. Loop unrolling increases the loop body size while simultaneously decreasing the number of iterations. Loop unrolling also increases the effectiveness of other optimizations.
    Feedback-directed optimizations: the Server VM performs extensive profiling of the program in the interpreter before compiling the Java bytecode to optimized machine code. This profiling data provides even more information to the compiler about data types in use, hot paths through the code, and other properties. The compiler uses this information to more aggressively and optimistically optimize the code in certain situations. If one of the assumed properties of the code is violated at run time, the code is deoptimized and later recompiled and reoptimized.


